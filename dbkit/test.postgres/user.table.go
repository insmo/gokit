package dbkit_tests

import (
	// db library
	_ "github.com/lib/pq"
	"bytes"
	"context"
	"database/sql"
	"github.com/oliverkofoed/gokit/logkit"
	"strconv"
	"time"
)

// UsersTable is generated by dbkit
type UsersTable struct {
	driver usersDriver
}

// Insert creates a record in the Users table
func (t UsersTable) Insert(ctx context.Context, birthdate time.Time, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, facebookUserID *string) (*User, error) {
	return t.driver.insert(ctx, birthdate, gender, created, lastSeen, interest, displayName, avatar, email, facebookUserID)
}

// Load a single record from the Users table based on the given query
func (t UsersTable) Load(ctx context.Context, query string, args ...interface{}) (*User, error) {
	return t.driver.load(ctx, query, args...)
}

// Delete deletes records from the Users table based on the given query
func (t UsersTable) Delete(ctx context.Context, query string, args ...interface{}) error {
	return t.driver.delete(ctx, query, args...)
}

// LoadByAvatar loads a single record from the Users table based on the given values
func (t UsersTable) LoadByAvatar(ctx context.Context, avatar string) (*User, error) {
	return t.driver.loadByAvatar(ctx, avatar)
}

// FindByAvatar finds records the Users table based on the given values
func (t UsersTable) FindByAvatar(avatar string) *UserQuery {
	return t.driver.findByAvatar(avatar)
}

// DeleteByAvatar deletes records the Users table based on the given values
func (t UsersTable) DeleteByAvatar(ctx context.Context, avatar string) error {
	return t.driver.deleteByAvatar(ctx,avatar)
}

// LoadByCreated loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreated(ctx context.Context, created time.Time) (*User, error) {
	return t.driver.loadByCreated(ctx, created)
}

// FindByCreated finds records the Users table based on the given values
func (t UsersTable) FindByCreated(created time.Time) *UserQuery {
	return t.driver.findByCreated(created)
}

// DeleteByCreated deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreated(ctx context.Context, created time.Time) error {
	return t.driver.deleteByCreated(ctx,created)
}

// LoadByCreatedAndGender loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreatedAndGender(ctx context.Context, created time.Time, gender int64) (*User, error) {
	return t.driver.loadByCreatedAndGender(ctx, created, gender)
}

// FindByCreatedAndGender finds records the Users table based on the given values
func (t UsersTable) FindByCreatedAndGender(created time.Time, gender int64) *UserQuery {
	return t.driver.findByCreatedAndGender(created, gender)
}

// DeleteByCreatedAndGender deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreatedAndGender(ctx context.Context, created time.Time, gender int64) error {
	return t.driver.deleteByCreatedAndGender(ctx,created, gender)
}

// LoadByCreatedAndGenderAndBirthdate loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) (*User, error) {
	return t.driver.loadByCreatedAndGenderAndBirthdate(ctx, created, gender, birthdate)
}

// FindByCreatedAndGenderAndBirthdate finds records the Users table based on the given values
func (t UsersTable) FindByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery {
	return t.driver.findByCreatedAndGenderAndBirthdate(created, gender, birthdate)
}

// DeleteByCreatedAndGenderAndBirthdate deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) error {
	return t.driver.deleteByCreatedAndGenderAndBirthdate(ctx,created, gender, birthdate)
}

// LoadByID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByID(ctx context.Context, id int64) (*User, error) {
	return t.driver.loadByID(ctx, id)
}

// FindByID finds records the Users table based on the given values
func (t UsersTable) FindByID(id int64) *UserQuery {
	return t.driver.findByID(id)
}

// DeleteByID deletes records the Users table based on the given values
func (t UsersTable) DeleteByID(ctx context.Context, id int64) error {
	return t.driver.deleteByID(ctx,id)
}

// LoadByEmail loads a single record from the Users table based on the given values
func (t UsersTable) LoadByEmail(ctx context.Context, email *string) (*User, error) {
	return t.driver.loadByEmail(ctx, email)
}

// FindByEmail finds records the Users table based on the given values
func (t UsersTable) FindByEmail(email *string) *UserQuery {
	return t.driver.findByEmail(email)
}

// DeleteByEmail deletes records the Users table based on the given values
func (t UsersTable) DeleteByEmail(ctx context.Context, email *string) error {
	return t.driver.deleteByEmail(ctx,email)
}

// LoadByFacebookUserID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByFacebookUserID(ctx context.Context, facebookUserID *string) (*User, error) {
	return t.driver.loadByFacebookUserID(ctx, facebookUserID)
}

// FindByFacebookUserID finds records the Users table based on the given values
func (t UsersTable) FindByFacebookUserID(facebookUserID *string) *UserQuery {
	return t.driver.findByFacebookUserID(facebookUserID)
}

// DeleteByFacebookUserID deletes records the Users table based on the given values
func (t UsersTable) DeleteByFacebookUserID(ctx context.Context, facebookUserID *string) error {
	return t.driver.deleteByFacebookUserID(ctx,facebookUserID)
}

// LoadByFacebookUserIDAndAvatar loads a single record from the Users table based on the given values
func (t UsersTable) LoadByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) (*User, error) {
	return t.driver.loadByFacebookUserIDAndAvatar(ctx, facebookUserID, avatar)
}

// FindByFacebookUserIDAndAvatar finds records the Users table based on the given values
func (t UsersTable) FindByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery {
	return t.driver.findByFacebookUserIDAndAvatar(facebookUserID, avatar)
}

// DeleteByFacebookUserIDAndAvatar deletes records the Users table based on the given values
func (t UsersTable) DeleteByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) error {
	return t.driver.deleteByFacebookUserIDAndAvatar(ctx,facebookUserID, avatar)
}

// Query creates a query for records in the Users table by id
func (t UsersTable) Query() *UserQuery {
	return &UserQuery{driver: t.driver}
}

// User represents a row in the Users table
type User struct {
	driver usersDriver
	ID      int64
	Birthdate      time.Time
	Gender      int64
	Created      time.Time
	LastSeen      time.Time
	Interest      int64
	DisplayName      string
	Avatar      string
	Email      *string
	FacebookUserID      *string
	
	loadID      int64
	loadBirthdate      time.Time
	loadGender      int64
	loadCreated      time.Time
	loadLastSeen      time.Time
	loadInterest      int64
	loadDisplayName      string
	loadAvatar      string
	loadEmail      *string
	loadFacebookUserID      *string
	
}

// Save saves any changes to the row
func (i *User) Save(ctx context.Context) error {
	return i.driver.save(ctx,i)
}

// UserQuery is a modifiable query against the Users table
type UserQuery struct {
	driver usersDriver

	whereQuery string
	orderColumns []string
	orderDirection []int
	args       []interface{}
	limit      int
}

// Limit changes the limit of the UserQuery query to the given value
func (q *UserQuery) Limit(limit int) *UserQuery {
	q.limit = limit
	return q
}

// SortAscendingBy adds an ascending sort column to the query
func (q *UserQuery) SortAscendingBy(column string) *UserQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, 1)
	return q
}

// SortDescendingBy adds an descending sort column to the query
func (q *UserQuery) SortDescendingBy(column string) *UserQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, -1)
	return q
}

// Where changes the where clause of the query
func (q *UserQuery) Where(where string, args ...interface{}) *UserQuery {
	q.whereQuery = where
	q.args = args //TODO: check if already have args, then add instead of set.
	return q
}

// First returns the first item found by the query
func (q *UserQuery) First(ctx context.Context) ( *User, error) {
	return q.driver.queryFirst(ctx,q)
}

// Slice returns a slice with all the matched item (warning: can use lots of memory)
func (q *UserQuery) Slice(ctx context.Context,expectedSliceSize int) ([]*User, error) {
	return q.driver.querySlice(ctx,q, expectedSliceSize)
}

// Each returns a slice with all the matched item (warning: can use lots of memory)
func (q *UserQuery) Each(ctx context.Context, reuseItem bool, action func(*User) error) error {
	return q.driver.queryEach(ctx, q, reuseItem, action)
}

type usersDriver interface {
	insert(ctx context.Context,birthdate time.Time, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, facebookUserID *string) (*User, error)
	load(ctx context.Context,query string, args ...interface{}) (*User, error)
	delete(ctx context.Context,query string, args ...interface{}) error
	save(ctx context.Context,user *User) error
	//scan(user *User, rows *sql.Rows) error
	queryFirst(ctx context.Context,query *UserQuery) (*User, error)
	querySlice(ctx context.Context,query *UserQuery, expectedSliceSize int) ([]*User, error)
	queryEach(ctx context.Context,query *UserQuery, reuseItem bool, action func(*User) error) error
	loadByID(ctx context.Context,id int64) (*User, error)
	findByID(id int64) *UserQuery
	deleteByID(ctx context.Context,id int64) error
	loadByEmail(ctx context.Context,email *string) (*User, error)
	findByEmail(email *string) *UserQuery
	deleteByEmail(ctx context.Context,email *string) error
	loadByFacebookUserID(ctx context.Context,facebookUserID *string) (*User, error)
	findByFacebookUserID(facebookUserID *string) *UserQuery
	deleteByFacebookUserID(ctx context.Context,facebookUserID *string) error
	loadByFacebookUserIDAndAvatar(ctx context.Context,facebookUserID *string, avatar string) (*User, error)
	findByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery
	deleteByFacebookUserIDAndAvatar(ctx context.Context,facebookUserID *string, avatar string) error
	loadByAvatar(ctx context.Context,avatar string) (*User, error)
	findByAvatar(avatar string) *UserQuery
	deleteByAvatar(ctx context.Context,avatar string) error
	loadByCreated(ctx context.Context,created time.Time) (*User, error)
	findByCreated(created time.Time) *UserQuery
	deleteByCreated(ctx context.Context,created time.Time) error
	loadByCreatedAndGender(ctx context.Context,created time.Time, gender int64) (*User, error)
	findByCreatedAndGender(created time.Time, gender int64) *UserQuery
	deleteByCreatedAndGender(ctx context.Context,created time.Time, gender int64) error
	loadByCreatedAndGenderAndBirthdate(ctx context.Context,created time.Time, gender int64, birthdate time.Time) (*User, error)
	findByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery
	deleteByCreatedAndGenderAndBirthdate(ctx context.Context,created time.Time, gender int64, birthdate time.Time) error
}


// -------- postgres --------

type usersPostgresDriver struct {
	db *sql.DB
}

func (d *usersPostgresDriver) insert(ctx context.Context, birthdate time.Time, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, facebookUserID *string) (*User, error) {
	if ctx == nil {
		ctx = context.Background()
	}

	
	sql := "insert into Users(birthdate, gender, created, last_seen, interest, display_name, avatar, email, facebook_user_id) values ($1, $2, $3, $4, $5, $6, $7, $8, $9) returning id"
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	var newID int64
	err := d.db.QueryRowContext(ctx,sql, birthdate, gender, created, lastSeen, interest, displayName, avatar, email, facebookUserID).Scan(&newID)
	
	if err != nil {
		return nil, err
	}

	return &User{
		driver:      d,
		
		ID: newID,
		loadID: newID,
		
		Birthdate:      birthdate,
		Gender:      gender,
		Created:      created,
		LastSeen:      lastSeen,
		Interest:      interest,
		DisplayName:      displayName,
		Avatar:      avatar,
		Email:      email,
		FacebookUserID:      facebookUserID,
		
		loadBirthdate:      birthdate,
		loadGender:      gender,
		loadCreated:      created,
		loadLastSeen:      lastSeen,
		loadInterest:      interest,
		loadDisplayName:      displayName,
		loadAvatar:      avatar,
		loadEmail:      email,
		loadFacebookUserID:      facebookUserID,
		
	}, nil
}

func (d *usersPostgresDriver) load(ctx context.Context, query string, args ...interface{}) (*User, error) {
	if ctx == nil {
		ctx = context.Background()
	}
	sql := "SELECT id, birthdate, gender, created, last_seen, interest, display_name, avatar, email, facebook_user_id from Users where "+query
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	rows, err := d.db.QueryContext(ctx,sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var item *User
	if rows.Next() {
		item = &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return item, nil
}

func (d *usersPostgresDriver) delete(ctx context.Context, query string, args ...interface{}) error {
	if ctx == nil {
		ctx = context.Background()
	}
	sql := "delete from Users where "+query
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	_, err := d.db.ExecContext(ctx,sql,args...);
	return err
}

func (d *usersPostgresDriver) scan(item *User, rows *sql.Rows) error {
	err := rows.Scan(&item.ID, &item.Birthdate, &item.Gender, &item.Created, &item.LastSeen, &item.Interest, &item.DisplayName, &item.Avatar, &item.Email, &item.FacebookUserID)
	if err != nil {
		return err
	}
	item.driver = d
	item.loadID = item.ID
	item.loadBirthdate = item.Birthdate
	item.loadGender = item.Gender
	item.loadCreated = item.Created
	item.loadLastSeen = item.LastSeen
	item.loadInterest = item.Interest
	item.loadDisplayName = item.DisplayName
	item.loadAvatar = item.Avatar
	item.loadEmail = item.Email
	item.loadFacebookUserID = item.FacebookUserID
	
	return nil
}

func (d *usersPostgresDriver) save(ctx context.Context, item *User) error {
	var sb bytes.Buffer
	sb.WriteString("update Users set ")
	args := make([]interface{}, 0, 10 )

	
	if item.ID != item.loadID { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.ID)
		sb.WriteString("id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.Birthdate != item.loadBirthdate { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Birthdate)
		sb.WriteString("birthdate=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.Gender != item.loadGender { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Gender)
		sb.WriteString("gender=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.Created != item.loadCreated { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Created)
		sb.WriteString("created=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.LastSeen != item.loadLastSeen { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.LastSeen)
		sb.WriteString("last_seen=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.Interest != item.loadInterest { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Interest)
		sb.WriteString("interest=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.DisplayName != item.loadDisplayName { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.DisplayName)
		sb.WriteString("display_name=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.Avatar != item.loadAvatar { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Avatar)
		sb.WriteString("avatar=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.Email != item.loadEmail { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Email)
		sb.WriteString("email=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.FacebookUserID != item.loadFacebookUserID { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.FacebookUserID)
		sb.WriteString("facebook_user_id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	

	// nothing changed!
	if len(args) == 0 {
		return nil
	}

	// where clause
	sb.WriteString(" where ")
	
	args = append(args, item.ID)
	sb.WriteString(" id=$")
	sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	

	// execute
	sql := sb.String()
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	if _, err := d.db.Exec(sql, args...); err != nil {
		return err
	}

	// reset load variables.
	item.loadID = item.ID
	item.loadBirthdate = item.Birthdate
	item.loadGender = item.Gender
	item.loadCreated = item.Created
	item.loadLastSeen = item.LastSeen
	item.loadInterest = item.Interest
	item.loadDisplayName = item.DisplayName
	item.loadAvatar = item.Avatar
	item.loadEmail = item.Email
	item.loadFacebookUserID = item.FacebookUserID
	

	return nil
}

func (d *usersPostgresDriver) queryFirst(ctx context.Context, query *UserQuery) (*User, error) {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var item *User
	if rows.Next() {
		item = &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return item, nil
}

func (d *usersPostgresDriver) querySlice(ctx context.Context, query *UserQuery, expectedSliceSize int) ([]*User, error) {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := make([]*User, 0, expectedSliceSize)
	for rows.Next() {
		item := &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return result, nil
}

func (d *usersPostgresDriver) queryEach(ctx context.Context, query *UserQuery, reuseItem bool, action func(*User) error) error {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	var item *User
	for rows.Next() {
		if item == nil || !reuseItem {
			item = &User{}
		}

		if err := d.scan(item, rows); err != nil {
			return err
		}

		if err := action(item); err != nil {
			return err
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

func (d *usersPostgresDriver) querySQL(query *UserQuery) string {
	var sb bytes.Buffer

	sb.WriteString("Select id, birthdate, gender, created, last_seen, interest, display_name, avatar, email, facebook_user_id from Users")

	if query.whereQuery != "" {
		sb.WriteString(" WHERE ")
		sb.WriteString(query.whereQuery)
	}
	if len(query.orderColumns) > 0 {
		sb.WriteString(" ORDER BY ")
		for i, col := range query.orderColumns {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(col)
			if query.orderDirection[i] == 1 {
				sb.WriteString(" ASC")
			}else{
				sb.WriteString(" DESC")
			}
		}

	}
	if query.limit > 0 {
		sb.WriteString(" LIMIT ")
		sb.WriteString(strconv.FormatInt(int64(query.limit), 10))
	}

	return sb.String()
}


func (d *usersPostgresDriver) loadByEmail(ctx context.Context, email *string) (*User, error) {
	return d.load(ctx,"email=$1", email)
}

func (d *usersPostgresDriver) findByEmail(email *string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("email=$1", email)
	return q
}

func (d *usersPostgresDriver) deleteByEmail(ctx context.Context, email *string) error {
	return d.delete(ctx,"email=$1", email)
}

func (d *usersPostgresDriver) loadByFacebookUserID(ctx context.Context, facebookUserID *string) (*User, error) {
	return d.load(ctx,"facebook_user_id=$1", facebookUserID)
}

func (d *usersPostgresDriver) findByFacebookUserID(facebookUserID *string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("facebook_user_id=$1", facebookUserID)
	return q
}

func (d *usersPostgresDriver) deleteByFacebookUserID(ctx context.Context, facebookUserID *string) error {
	return d.delete(ctx,"facebook_user_id=$1", facebookUserID)
}

func (d *usersPostgresDriver) loadByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) (*User, error) {
	return d.load(ctx,"facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
}

func (d *usersPostgresDriver) findByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
	return q
}

func (d *usersPostgresDriver) deleteByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) error {
	return d.delete(ctx,"facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
}

func (d *usersPostgresDriver) loadByAvatar(ctx context.Context, avatar string) (*User, error) {
	return d.load(ctx,"avatar=$1", avatar)
}

func (d *usersPostgresDriver) findByAvatar(avatar string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("avatar=$1", avatar)
	return q
}

func (d *usersPostgresDriver) deleteByAvatar(ctx context.Context, avatar string) error {
	return d.delete(ctx,"avatar=$1", avatar)
}

func (d *usersPostgresDriver) loadByCreated(ctx context.Context, created time.Time) (*User, error) {
	return d.load(ctx,"created=$1", created)
}

func (d *usersPostgresDriver) findByCreated(created time.Time) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1", created)
	return q
}

func (d *usersPostgresDriver) deleteByCreated(ctx context.Context, created time.Time) error {
	return d.delete(ctx,"created=$1", created)
}

func (d *usersPostgresDriver) loadByCreatedAndGender(ctx context.Context, created time.Time, gender int64) (*User, error) {
	return d.load(ctx,"created=$1 and gender=$2", created, gender)
}

func (d *usersPostgresDriver) findByCreatedAndGender(created time.Time, gender int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1 and gender=$2", created, gender)
	return q
}

func (d *usersPostgresDriver) deleteByCreatedAndGender(ctx context.Context, created time.Time, gender int64) error {
	return d.delete(ctx,"created=$1 and gender=$2", created, gender)
}

func (d *usersPostgresDriver) loadByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) (*User, error) {
	return d.load(ctx,"created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
}

func (d *usersPostgresDriver) findByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
	return q
}

func (d *usersPostgresDriver) deleteByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) error {
	return d.delete(ctx,"created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
}

func (d *usersPostgresDriver) loadByID(ctx context.Context, id int64) (*User, error) {
	return d.load(ctx,"id=$1", id)
}

func (d *usersPostgresDriver) findByID(id int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("id=$1", id)
	return q
}

func (d *usersPostgresDriver) deleteByID(ctx context.Context, id int64) error {
	return d.delete(ctx,"id=$1", id)
}
