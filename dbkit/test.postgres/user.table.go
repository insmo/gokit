package dbkit_tests

import (
	// db library
	_ "github.com/lib/pq"
	"bytes"
	"context"
	"database/sql"
	"fmt"
	"github.com/oliverkofoed/gokit/logkit"
	"github.com/satori/go.uuid"
	"strconv"
	"time"
)

// UsersTable is generated by dbkit
type UsersTable struct {
	BeforeUpdate func(context.Context, *User) error
	AfterUpdate func(context.Context, *User) 
	BeforeInsert func(context.Context, *User) error
	AfterInsert func(context.Context, *User) 
	driver usersDriver
}

// Execute runs a raw comand against the database
func (t UsersTable) Execute(ctx context.Context, command string, args ...interface{}) error{
	return t.driver.execute(ctx, command, args...)
}

// Insert creates a record in the Users table
func (t UsersTable) Insert(ctx context.Context, birthdate time.Time, anotherID uuid.UUID, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, facebookUserID *string) (*User, error) {
	return t.driver.insert(ctx, birthdate, anotherID, gender, created, lastSeen, interest, displayName, avatar, email, facebookUserID)
}

// Load a single record from the Users table based on the given query
func (t UsersTable) Load(ctx context.Context, query string, args ...interface{}) (*User, error) {
	return t.driver.load(ctx, query, args...)
}

// Delete deletes records from the Users table based on the given query
func (t UsersTable) Delete(ctx context.Context, query string, args ...interface{}) error {
	return t.driver.delete(ctx, query, args...)
}

// LoadByID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByID(ctx context.Context, id int64) (*User, error) {
	return t.driver.loadByID(ctx, id)
}

// FindByID finds records the Users table based on the given values
func (t UsersTable) FindByID(id int64) *UserQuery {
	return t.driver.findByID(id)
}

// DeleteByID deletes records the Users table based on the given values
func (t UsersTable) DeleteByID(ctx context.Context, id int64) error {
	return t.driver.deleteByID(ctx,id)
}

// LoadByAnotherID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByAnotherID(ctx context.Context, anotherID uuid.UUID) (*User, error) {
	return t.driver.loadByAnotherID(ctx, anotherID)
}

// FindByAnotherID finds records the Users table based on the given values
func (t UsersTable) FindByAnotherID(anotherID uuid.UUID) *UserQuery {
	return t.driver.findByAnotherID(anotherID)
}

// DeleteByAnotherID deletes records the Users table based on the given values
func (t UsersTable) DeleteByAnotherID(ctx context.Context, anotherID uuid.UUID) error {
	return t.driver.deleteByAnotherID(ctx,anotherID)
}

// LoadByAnotherIDAndGender loads a single record from the Users table based on the given values
func (t UsersTable) LoadByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) (*User, error) {
	return t.driver.loadByAnotherIDAndGender(ctx, anotherID, gender)
}

// FindByAnotherIDAndGender finds records the Users table based on the given values
func (t UsersTable) FindByAnotherIDAndGender(anotherID uuid.UUID, gender int64) *UserQuery {
	return t.driver.findByAnotherIDAndGender(anotherID, gender)
}

// DeleteByAnotherIDAndGender deletes records the Users table based on the given values
func (t UsersTable) DeleteByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) error {
	return t.driver.deleteByAnotherIDAndGender(ctx,anotherID, gender)
}

// LoadByEmail loads a single record from the Users table based on the given values
func (t UsersTable) LoadByEmail(ctx context.Context, email *string) (*User, error) {
	return t.driver.loadByEmail(ctx, email)
}

// FindByEmail finds records the Users table based on the given values
func (t UsersTable) FindByEmail(email *string) *UserQuery {
	return t.driver.findByEmail(email)
}

// DeleteByEmail deletes records the Users table based on the given values
func (t UsersTable) DeleteByEmail(ctx context.Context, email *string) error {
	return t.driver.deleteByEmail(ctx,email)
}

// LoadByFacebookUserID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByFacebookUserID(ctx context.Context, facebookUserID *string) (*User, error) {
	return t.driver.loadByFacebookUserID(ctx, facebookUserID)
}

// FindByFacebookUserID finds records the Users table based on the given values
func (t UsersTable) FindByFacebookUserID(facebookUserID *string) *UserQuery {
	return t.driver.findByFacebookUserID(facebookUserID)
}

// DeleteByFacebookUserID deletes records the Users table based on the given values
func (t UsersTable) DeleteByFacebookUserID(ctx context.Context, facebookUserID *string) error {
	return t.driver.deleteByFacebookUserID(ctx,facebookUserID)
}

// LoadByFacebookUserIDAndAvatar loads a single record from the Users table based on the given values
func (t UsersTable) LoadByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) (*User, error) {
	return t.driver.loadByFacebookUserIDAndAvatar(ctx, facebookUserID, avatar)
}

// FindByFacebookUserIDAndAvatar finds records the Users table based on the given values
func (t UsersTable) FindByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery {
	return t.driver.findByFacebookUserIDAndAvatar(facebookUserID, avatar)
}

// DeleteByFacebookUserIDAndAvatar deletes records the Users table based on the given values
func (t UsersTable) DeleteByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) error {
	return t.driver.deleteByFacebookUserIDAndAvatar(ctx,facebookUserID, avatar)
}

// LoadByAvatar loads a single record from the Users table based on the given values
func (t UsersTable) LoadByAvatar(ctx context.Context, avatar string) (*User, error) {
	return t.driver.loadByAvatar(ctx, avatar)
}

// FindByAvatar finds records the Users table based on the given values
func (t UsersTable) FindByAvatar(avatar string) *UserQuery {
	return t.driver.findByAvatar(avatar)
}

// DeleteByAvatar deletes records the Users table based on the given values
func (t UsersTable) DeleteByAvatar(ctx context.Context, avatar string) error {
	return t.driver.deleteByAvatar(ctx,avatar)
}

// LoadByCreated loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreated(ctx context.Context, created time.Time) (*User, error) {
	return t.driver.loadByCreated(ctx, created)
}

// FindByCreated finds records the Users table based on the given values
func (t UsersTable) FindByCreated(created time.Time) *UserQuery {
	return t.driver.findByCreated(created)
}

// DeleteByCreated deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreated(ctx context.Context, created time.Time) error {
	return t.driver.deleteByCreated(ctx,created)
}

// LoadByCreatedAndGender loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreatedAndGender(ctx context.Context, created time.Time, gender int64) (*User, error) {
	return t.driver.loadByCreatedAndGender(ctx, created, gender)
}

// FindByCreatedAndGender finds records the Users table based on the given values
func (t UsersTable) FindByCreatedAndGender(created time.Time, gender int64) *UserQuery {
	return t.driver.findByCreatedAndGender(created, gender)
}

// DeleteByCreatedAndGender deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreatedAndGender(ctx context.Context, created time.Time, gender int64) error {
	return t.driver.deleteByCreatedAndGender(ctx,created, gender)
}

// LoadByCreatedAndGenderAndBirthdate loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) (*User, error) {
	return t.driver.loadByCreatedAndGenderAndBirthdate(ctx, created, gender, birthdate)
}

// FindByCreatedAndGenderAndBirthdate finds records the Users table based on the given values
func (t UsersTable) FindByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery {
	return t.driver.findByCreatedAndGenderAndBirthdate(created, gender, birthdate)
}

// DeleteByCreatedAndGenderAndBirthdate deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) error {
	return t.driver.deleteByCreatedAndGenderAndBirthdate(ctx,created, gender, birthdate)
}

// Query creates a query for records in the Users table by id
func (t UsersTable) Query() *UserQuery {
	return &UserQuery{driver: t.driver}
}

// User represents a row in the Users table
type User struct {
	driver usersDriver
	ID      int64
	Birthdate      time.Time
	AnotherID      uuid.UUID
	Gender      int64
	Created      time.Time
	LastSeen      time.Time
	Interest      int64
	DisplayName      string
	Avatar      string
	Email      *string
	FacebookUserID      *string
	
	loadID      int64
	loadBirthdate      time.Time
	loadAnotherID      uuid.UUID
	loadGender      int64
	loadCreated      time.Time
	loadLastSeen      time.Time
	loadInterest      int64
	loadDisplayName      string
	loadAvatar      string
	loadEmail      *string
	loadFacebookUserID      *string
	
}

// Save saves any changes to the row
func (i *User) Save(ctx context.Context) error {
	return i.driver.save(ctx,i)
}

// UserQuery is a modifiable query against the Users table
type UserQuery struct {
	driver usersDriver

	whereQuery string
	orderColumns []string
	orderDirection []int
	args       []interface{}
	limit      int
}

// Limit changes the limit of the UserQuery query to the given value
func (q *UserQuery) Limit(limit int) *UserQuery {
	q.limit = limit
	return q
}

// SortAscendingBy adds an ascending sort column to the query
func (q *UserQuery) SortAscendingBy(column string) *UserQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, 1)
	return q
}

// SortDescendingBy adds an descending sort column to the query
func (q *UserQuery) SortDescendingBy(column string) *UserQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, -1)
	return q
}

// Where changes the where clause of the query
func (q *UserQuery) Where(where string, args ...interface{}) *UserQuery {
	q.whereQuery = where
	q.args = args //TODO: check if already have args, then add instead of set.
	return q
}

// First returns the first item found by the query
func (q *UserQuery) First(ctx context.Context) ( *User, error) {
	return q.driver.queryFirst(ctx,q)
}

// Slice returns a slice with all the matched item (warning: can use lots of memory)
func (q *UserQuery) Slice(ctx context.Context,expectedSliceSize int) ([]*User, error) {
	return q.driver.querySlice(ctx,q, expectedSliceSize)
}

// Each returns a slice with all the matched item (warning: can use lots of memory)
func (q *UserQuery) Each(ctx context.Context, reuseItem bool, action func(*User) error) error {
	return q.driver.queryEach(ctx, q, reuseItem, action)
}

type usersDriver interface {
	execute(ctx context.Context,query string, args ...interface{}) error
	insert(ctx context.Context,birthdate time.Time, anotherID uuid.UUID, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, facebookUserID *string) (*User, error)
	load(ctx context.Context,query string, args ...interface{}) (*User, error)
	delete(ctx context.Context,query string, args ...interface{}) error
	save(ctx context.Context,user *User) error
	//scan(user *User, rows *sql.Rows) error
	queryFirst(ctx context.Context,query *UserQuery) (*User, error)
	querySlice(ctx context.Context,query *UserQuery, expectedSliceSize int) ([]*User, error)
	queryEach(ctx context.Context,query *UserQuery, reuseItem bool, action func(*User) error) error
	loadByID(ctx context.Context,id int64) (*User, error)
	findByID(id int64) *UserQuery
	deleteByID(ctx context.Context,id int64) error
	loadByAnotherID(ctx context.Context,anotherID uuid.UUID) (*User, error)
	findByAnotherID(anotherID uuid.UUID) *UserQuery
	deleteByAnotherID(ctx context.Context,anotherID uuid.UUID) error
	loadByAnotherIDAndGender(ctx context.Context,anotherID uuid.UUID, gender int64) (*User, error)
	findByAnotherIDAndGender(anotherID uuid.UUID, gender int64) *UserQuery
	deleteByAnotherIDAndGender(ctx context.Context,anotherID uuid.UUID, gender int64) error
	loadByEmail(ctx context.Context,email *string) (*User, error)
	findByEmail(email *string) *UserQuery
	deleteByEmail(ctx context.Context,email *string) error
	loadByFacebookUserID(ctx context.Context,facebookUserID *string) (*User, error)
	findByFacebookUserID(facebookUserID *string) *UserQuery
	deleteByFacebookUserID(ctx context.Context,facebookUserID *string) error
	loadByFacebookUserIDAndAvatar(ctx context.Context,facebookUserID *string, avatar string) (*User, error)
	findByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery
	deleteByFacebookUserIDAndAvatar(ctx context.Context,facebookUserID *string, avatar string) error
	loadByAvatar(ctx context.Context,avatar string) (*User, error)
	findByAvatar(avatar string) *UserQuery
	deleteByAvatar(ctx context.Context,avatar string) error
	loadByCreated(ctx context.Context,created time.Time) (*User, error)
	findByCreated(created time.Time) *UserQuery
	deleteByCreated(ctx context.Context,created time.Time) error
	loadByCreatedAndGender(ctx context.Context,created time.Time, gender int64) (*User, error)
	findByCreatedAndGender(created time.Time, gender int64) *UserQuery
	deleteByCreatedAndGender(ctx context.Context,created time.Time, gender int64) error
	loadByCreatedAndGenderAndBirthdate(ctx context.Context,created time.Time, gender int64, birthdate time.Time) (*User, error)
	findByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery
	deleteByCreatedAndGenderAndBirthdate(ctx context.Context,created time.Time, gender int64, birthdate time.Time) error
}

// IsDirty returns true if any of the values the originally loaded values
func (i *User) IsDirty() bool {
	if i.ID != i.loadID {
		return true
	}
	if i.Birthdate != i.loadBirthdate {
		return true
	}
	if !bytes.Equal(i.AnotherID.Bytes(),i.loadAnotherID.Bytes()) {
		return true
	}
	if i.Gender != i.loadGender {
		return true
	}
	if i.Created != i.loadCreated {
		return true
	}
	if i.LastSeen != i.loadLastSeen {
		return true
	}
	if i.Interest != i.loadInterest {
		return true
	}
	if i.DisplayName != i.loadDisplayName {
		return true
	}
	if i.Avatar != i.loadAvatar {
		return true
	}
	if i.Email != i.loadEmail && !(i.Email != nil && i.loadEmail != nil && *i.Email == *i.loadEmail) {
		return true
	}
	if i.FacebookUserID != i.loadFacebookUserID && !(i.FacebookUserID != nil && i.loadFacebookUserID != nil && *i.FacebookUserID == *i.loadFacebookUserID) {
		return true
	}
	
	return false
}

// IsDirtyID returns true if the ID value differs from the originally loaded value
func (i *User) IsDirtyID() bool {
	return i.ID != i.loadID
}

// IsDirtyBirthdate returns true if the Birthdate value differs from the originally loaded value
func (i *User) IsDirtyBirthdate() bool {
	return i.Birthdate != i.loadBirthdate
}

// IsDirtyAnotherID returns true if the AnotherID value differs from the originally loaded value
func (i *User) IsDirtyAnotherID() bool {
	return !bytes.Equal(i.AnotherID.Bytes(),i.loadAnotherID.Bytes())
}

// IsDirtyGender returns true if the Gender value differs from the originally loaded value
func (i *User) IsDirtyGender() bool {
	return i.Gender != i.loadGender
}

// IsDirtyCreated returns true if the Created value differs from the originally loaded value
func (i *User) IsDirtyCreated() bool {
	return i.Created != i.loadCreated
}

// IsDirtyLastSeen returns true if the LastSeen value differs from the originally loaded value
func (i *User) IsDirtyLastSeen() bool {
	return i.LastSeen != i.loadLastSeen
}

// IsDirtyInterest returns true if the Interest value differs from the originally loaded value
func (i *User) IsDirtyInterest() bool {
	return i.Interest != i.loadInterest
}

// IsDirtyDisplayName returns true if the DisplayName value differs from the originally loaded value
func (i *User) IsDirtyDisplayName() bool {
	return i.DisplayName != i.loadDisplayName
}

// IsDirtyAvatar returns true if the Avatar value differs from the originally loaded value
func (i *User) IsDirtyAvatar() bool {
	return i.Avatar != i.loadAvatar
}

// IsDirtyEmail returns true if the Email value differs from the originally loaded value
func (i *User) IsDirtyEmail() bool {
	return i.Email != i.loadEmail && !(i.Email != nil && i.loadEmail != nil && *i.Email == *i.loadEmail)
}

// IsDirtyFacebookUserID returns true if the FacebookUserID value differs from the originally loaded value
func (i *User) IsDirtyFacebookUserID() bool {
	return i.FacebookUserID != i.loadFacebookUserID && !(i.FacebookUserID != nil && i.loadFacebookUserID != nil && *i.FacebookUserID == *i.loadFacebookUserID)
}



// -------- postgres --------

type usersPostgresDriver struct {
	table *UsersTable
	db *sql.DB
}

func (d *usersPostgresDriver) execute(ctx context.Context, query string, args ...interface{}) error {
	if ctx == nil {
		ctx = context.Background()
	}
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",query))
	defer done()

	_, err := d.db.ExecContext(ctx,query,args...);
	return err
}

func (d *usersPostgresDriver) insert(ctx context.Context, birthdate time.Time, anotherID uuid.UUID, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, facebookUserID *string) (*User, error) {
	if ctx == nil {
		ctx = context.Background()
	}

	item := User{
		driver:      d,
		Birthdate:      birthdate,
		AnotherID:      anotherID,
		Gender:      gender,
		Created:      created,
		LastSeen:      lastSeen,
		Interest:      interest,
		DisplayName:      displayName,
		Avatar:      avatar,
		Email:      email,
		FacebookUserID:      facebookUserID,
		
		loadBirthdate:      birthdate,
		loadAnotherID:      anotherID,
		loadGender:      gender,
		loadCreated:      created,
		loadLastSeen:      lastSeen,
		loadInterest:      interest,
		loadDisplayName:      displayName,
		loadAvatar:      avatar,
		loadEmail:      email,
		loadFacebookUserID:      facebookUserID,
		
	}

	if d.table.BeforeInsert != nil {
		err := d.table.BeforeInsert(ctx, &item)
		if err != nil {
			return nil, fmt.Errorf("BeforeInsert error: %v", err)
		}
	}

	
	sql := "insert into Users(birthdate, another_id, gender, created, last_seen, interest, display_name, avatar, email, facebook_user_id) values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) returning id"
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	var newID int64
	err := d.db.QueryRowContext(ctx,sql, birthdate, anotherID, gender, created, lastSeen, interest, displayName, avatar, email, facebookUserID).Scan(&newID)
	
	if err != nil {
		return nil, err
	}

	
	item.ID = newID
	item.loadID = newID
	

	if d.table.AfterInsert != nil {
		d.table.AfterInsert(ctx, &item)
	}

	return &item, nil
}

func (d *usersPostgresDriver) load(ctx context.Context, query string, args ...interface{}) (*User, error) {
	if ctx == nil {
		ctx = context.Background()
	}
	sql := "SELECT id, birthdate, another_id, gender, created, last_seen, interest, display_name, avatar, email, facebook_user_id from Users where "+query
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	rows, err := d.db.QueryContext(ctx,sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var item *User
	if rows.Next() {
		item = &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return item, nil
}

func (d *usersPostgresDriver) delete(ctx context.Context, query string, args ...interface{}) error {
	if ctx == nil {
		ctx = context.Background()
	}
	sql := "delete from Users where "+query
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	_, err := d.db.ExecContext(ctx,sql,args...);
	return err
}

func (d *usersPostgresDriver) scan(item *User, rows *sql.Rows) error {
	err := rows.Scan(&item.ID, &item.Birthdate, &item.AnotherID, &item.Gender, &item.Created, &item.LastSeen, &item.Interest, &item.DisplayName, &item.Avatar, &item.Email, &item.FacebookUserID)
	if err != nil {
		return err
	}
	item.driver = d
	item.loadID = item.ID
	item.loadBirthdate = item.Birthdate
	item.loadAnotherID = item.AnotherID
	item.loadGender = item.Gender
	item.loadCreated = item.Created
	item.loadLastSeen = item.LastSeen
	item.loadInterest = item.Interest
	item.loadDisplayName = item.DisplayName
	item.loadAvatar = item.Avatar
	item.loadEmail = item.Email
	item.loadFacebookUserID = item.FacebookUserID
	
	return nil
}

func (d *usersPostgresDriver) save(ctx context.Context, item *User) error {
	if d.table.BeforeUpdate != nil {
		err := d.table.BeforeUpdate(ctx, item)
		if err != nil {
			return fmt.Errorf("BeforeSave error: %v", err)
		}
	}

	sql, args := getSaveUserSQL(item,1)

	// nothing changed
	if sql == "" {
		return nil
	}

	// execute
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	if _, err := d.db.Exec(sql, args...); err != nil {
		return logkit.Error(ctx, "SQL Error", logkit.String("sql",sql), logkit.Err(err))
	}

	// reset load variables.
	item.resetLoadVars()

	if d.table.AfterUpdate != nil {
		d.table.AfterUpdate(ctx, item)
	}

	return nil
}

func getSaveUserSQL(item *User, argOffset int) (string, []interface{}) {
	var sb bytes.Buffer
	sb.WriteString("update Users set ")
	args := make([]interface{}, 0, 11 )

	
	if item.ID != item.loadID { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.ID)
	}
	
	if item.Birthdate != item.loadBirthdate { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("birthdate=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Birthdate)
	}
	
	if !bytes.Equal(item.AnotherID.Bytes(),item.loadAnotherID.Bytes()) { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("another_id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.AnotherID)
	}
	
	if item.Gender != item.loadGender { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("gender=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Gender)
	}
	
	if item.Created != item.loadCreated { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("created=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Created)
	}
	
	if item.LastSeen != item.loadLastSeen { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("last_seen=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.LastSeen)
	}
	
	if item.Interest != item.loadInterest { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("interest=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Interest)
	}
	
	if item.DisplayName != item.loadDisplayName { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("display_name=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.DisplayName)
	}
	
	if item.Avatar != item.loadAvatar { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("avatar=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Avatar)
	}
	
	if item.Email != item.loadEmail && !(item.Email != nil && item.loadEmail != nil && *item.Email == *item.loadEmail) { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("email=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Email)
	}
	
	if item.FacebookUserID != item.loadFacebookUserID && !(item.FacebookUserID != nil && item.loadFacebookUserID != nil && *item.FacebookUserID == *item.loadFacebookUserID) { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("facebook_user_id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.FacebookUserID)
	}
	

	if len(args) == 0 {
		return "", args
	}

	// where clause
	sb.WriteString(" where")
	
	sb.WriteString(" id=$")
	sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
	args = append(args, item.ID)
	

	return sb.String(), args
}

func (i *User) resetLoadVars(){
	i.loadID = i.ID
	i.loadBirthdate = i.Birthdate
	i.loadAnotherID = i.AnotherID
	i.loadGender = i.Gender
	i.loadCreated = i.Created
	i.loadLastSeen = i.LastSeen
	i.loadInterest = i.Interest
	i.loadDisplayName = i.DisplayName
	i.loadAvatar = i.Avatar
	i.loadEmail = i.Email
	i.loadFacebookUserID = i.FacebookUserID
	
}

func (d *usersPostgresDriver) queryFirst(ctx context.Context, query *UserQuery) (*User, error) {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var item *User
	if rows.Next() {
		item = &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return item, nil
}

func (d *usersPostgresDriver) querySlice(ctx context.Context, query *UserQuery, expectedSliceSize int) ([]*User, error) {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := make([]*User, 0, expectedSliceSize)
	for rows.Next() {
		item := &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return result, nil
}

func (d *usersPostgresDriver) queryEach(ctx context.Context, query *UserQuery, reuseItem bool, action func(*User) error) error {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	var item *User
	for rows.Next() {
		if item == nil || !reuseItem {
			item = &User{}
		}

		if err := d.scan(item, rows); err != nil {
			return err
		}

		if err := action(item); err != nil {
			return err
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

func (d *usersPostgresDriver) querySQL(query *UserQuery) string {
	var sb bytes.Buffer

	sb.WriteString("Select id, birthdate, another_id, gender, created, last_seen, interest, display_name, avatar, email, facebook_user_id from Users")

	if query.whereQuery != "" {
		sb.WriteString(" WHERE ")
		sb.WriteString(query.whereQuery)
	}
	if len(query.orderColumns) > 0 {
		sb.WriteString(" ORDER BY ")
		for i, col := range query.orderColumns {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(col)
			if query.orderDirection[i] == 1 {
				sb.WriteString(" ASC")
			}else{
				sb.WriteString(" DESC")
			}
		}

	}
	if query.limit > 0 {
		sb.WriteString(" LIMIT ")
		sb.WriteString(strconv.FormatInt(int64(query.limit), 10))
	}

	return sb.String()
}


func (d *usersPostgresDriver) loadByID(ctx context.Context, id int64) (*User, error) {
	return d.load(ctx,"id=$1", id)
}

func (d *usersPostgresDriver) findByID(id int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("id=$1", id)
	return q
}

func (d *usersPostgresDriver) deleteByID(ctx context.Context, id int64) error {
	return d.delete(ctx,"id=$1", id)
}

func (d *usersPostgresDriver) loadByAnotherID(ctx context.Context, anotherID uuid.UUID) (*User, error) {
	return d.load(ctx,"another_id=$1", anotherID)
}

func (d *usersPostgresDriver) findByAnotherID(anotherID uuid.UUID) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("another_id=$1", anotherID)
	return q
}

func (d *usersPostgresDriver) deleteByAnotherID(ctx context.Context, anotherID uuid.UUID) error {
	return d.delete(ctx,"another_id=$1", anotherID)
}

func (d *usersPostgresDriver) loadByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) (*User, error) {
	return d.load(ctx,"another_id=$1 and gender=$2", anotherID, gender)
}

func (d *usersPostgresDriver) findByAnotherIDAndGender(anotherID uuid.UUID, gender int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("another_id=$1 and gender=$2", anotherID, gender)
	return q
}

func (d *usersPostgresDriver) deleteByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) error {
	return d.delete(ctx,"another_id=$1 and gender=$2", anotherID, gender)
}

func (d *usersPostgresDriver) loadByEmail(ctx context.Context, email *string) (*User, error) {
	return d.load(ctx,"email=$1", email)
}

func (d *usersPostgresDriver) findByEmail(email *string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("email=$1", email)
	return q
}

func (d *usersPostgresDriver) deleteByEmail(ctx context.Context, email *string) error {
	return d.delete(ctx,"email=$1", email)
}

func (d *usersPostgresDriver) loadByFacebookUserID(ctx context.Context, facebookUserID *string) (*User, error) {
	return d.load(ctx,"facebook_user_id=$1", facebookUserID)
}

func (d *usersPostgresDriver) findByFacebookUserID(facebookUserID *string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("facebook_user_id=$1", facebookUserID)
	return q
}

func (d *usersPostgresDriver) deleteByFacebookUserID(ctx context.Context, facebookUserID *string) error {
	return d.delete(ctx,"facebook_user_id=$1", facebookUserID)
}

func (d *usersPostgresDriver) loadByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) (*User, error) {
	return d.load(ctx,"facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
}

func (d *usersPostgresDriver) findByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
	return q
}

func (d *usersPostgresDriver) deleteByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) error {
	return d.delete(ctx,"facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
}

func (d *usersPostgresDriver) loadByAvatar(ctx context.Context, avatar string) (*User, error) {
	return d.load(ctx,"avatar=$1", avatar)
}

func (d *usersPostgresDriver) findByAvatar(avatar string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("avatar=$1", avatar)
	return q
}

func (d *usersPostgresDriver) deleteByAvatar(ctx context.Context, avatar string) error {
	return d.delete(ctx,"avatar=$1", avatar)
}

func (d *usersPostgresDriver) loadByCreated(ctx context.Context, created time.Time) (*User, error) {
	return d.load(ctx,"created=$1", created)
}

func (d *usersPostgresDriver) findByCreated(created time.Time) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1", created)
	return q
}

func (d *usersPostgresDriver) deleteByCreated(ctx context.Context, created time.Time) error {
	return d.delete(ctx,"created=$1", created)
}

func (d *usersPostgresDriver) loadByCreatedAndGender(ctx context.Context, created time.Time, gender int64) (*User, error) {
	return d.load(ctx,"created=$1 and gender=$2", created, gender)
}

func (d *usersPostgresDriver) findByCreatedAndGender(created time.Time, gender int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1 and gender=$2", created, gender)
	return q
}

func (d *usersPostgresDriver) deleteByCreatedAndGender(ctx context.Context, created time.Time, gender int64) error {
	return d.delete(ctx,"created=$1 and gender=$2", created, gender)
}

func (d *usersPostgresDriver) loadByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) (*User, error) {
	return d.load(ctx,"created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
}

func (d *usersPostgresDriver) findByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
	return q
}

func (d *usersPostgresDriver) deleteByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) error {
	return d.delete(ctx,"created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
}
